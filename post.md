# Ասեմբլեր գրելու մասին

Գո (Go) լեզուն սովորելու իմ հերթական «դասի» նախագիծը _վիրտուալ մեքենայի_ իրականացումն է։ Այդ վիրտուալ մեքենան սահմանված է Reinhard Wilhelm-ի և Helmut Seidl-ի հեղինակած _Compiler Design։ Virtual Machines_ (Springer, 2010) գրքի երկրորդ գլխում: Այդ պարզագույն _ստեկային_ վիրտուալ մեքենան նախատեսված է _իմպերատիվ_ ծրագրավորման լեզուները սպասարկելու համար։ Դրա համար շատ հեշտ է կոդ գեներացնել, և շատ հետշտ է իրականացնել այդ վիրտուալ մեքենայի հրամանների ինտերպրետատորը՝ մեքենային էմուլյատորը։ Իմ իրականացումը չնչին շեղումներ է պարունակում գրքում նբկարագրվածից։

ՎՄ-ի հրամանների համակարգը շատ մեծ չէ՝ մինչև 40 հրաման, իսկ դրանցից որոշները կարող են իրականացվել մյուսների օգնությամբ։ Քանի որ ճարտարապետությունը ստեկային է, ապա շատ հրամաններ արգումենտներ չեն ստանում, օրինակ, ստեկի գագաթի երկու թվերի հավասարությունը ստուգող `eq` հրամանը։ Որոշ հրամաններ ստանում են մեկ արգումենտ, որը կարող է՝ լինել կա՛մ թվային, օրինակ, `loadc` հրամանը իր արգումենտում տրված ամբողջաթիվ արգումենտը ավելացնում է ստեկի գագաթում, կա՛մ նիշային, օրինակ, `jump` հրամանը ղեկավարումը փոխանցում է իրա արգումենտում տրված պիտակով կետին։ Եվ միայն մեկ հրաման է, որ ստանում է երկու արգումենտ։ Նշեմ նաև, որ մեքենայի ճարտարապետությունը թույլատրում է միայն ամբողջաթիվ տվյալներ (հասցեները կամ ցուցիչները նույնպես ներկայացվում են որպես ամբողջ թվեր)։ Ավելի մանրամասն տե՛ս բերը հիշատակված գրքում։

Ես այս նախագիծը սկսեցի _ասեմբլերի_ իրականացումով, որը կարդում է ծրագիրը պարունակող տեքստային ֆայլը և կառուցում է համապատասխան _բայթ-կոդը_։ Օրինակ, եթե տրված է հետևյալ (անիմաստ) ծրագիրը.

````
begin:
    loadc 4
    loadc 2
    add
    halt
````

Ապա այն կարող է թարգմանվել հետևյալ բայթ-կոդի (տասնվեցական տեսքով). `13040000001302000000010B`։

Ասեմբլերի իմ իրականացումն (առայժմ) ունի երեք փաթեթ. `assembler`, `bytecode` և `machine`: `assembler` փաթեթում իրականացված է տեքստային լեզվի վերլուծությունն ու կոդի գեներացիան։ `bytecode` փաթեթում իրականացված են բայթ-կոդի կաոռւցման միջոցները։ `machine` փաթեթում իրականացված է վիրտուալ մեքենան՝ էմուլյատորը։


## Ասեմբլերի լեզուն և դրա վերլուծությունը

Վիրտուալ մեքենայի ծրագրերը տեքստային եղանակով ներկայացնելու համար օգտագործվում է մի պարզ լեզու, որի քերականությունը բերված է ստորև։

````
Program
    = {NL} { Line NL{NL} } EOS.

Line
    = Label 
    | Instruction
    | Label Instruction.

Label
    = IDENT ':'.

Instruction
    = KEYWORD
    | KEYWORD Argument
    | KEYWORD Argument Argument.

Argument
    = INTEGER
    | IDENT.
````

Քերականության տերմինալային սիմվոլներն են `NL`, `IDENT`, `KEYWORD`, `INTEGER`, `COLON` (`:`), `EOS`: Սրանց համապատասխան սահմանել եմ հաստատուններ.

````Go
const (
	xNone = iota
	xNumber
	xIdent
	xKeyword
	xNewLine
	xColon
	xEos
)
````

Բառային վերլուծիչը՝ իրականացված `next()` ֆունկցիայի տեսքով, կարդում է ծրագրի տեքստը և այն տրոհում է տերմինալային սիմվոլների (ընթացքում կարդալով ու դեն նետելով մեկնաբանությունները)։

````Go
func next() {
	ch := read()

	for ch == ' ' || ch == '\t' || ch == '\r' {
		ch = read()
	}

	switch {
	case ch == 0:
		look = lexeme{xEos, "EOS"}
	case ch == ';':
		for ch != '\n' {
			ch = read()
		}
		source.UnreadRune()
		next()
	case ch == ':':
		look = lexeme{xColon, ":"}
	case ch == '\n':
		look = lexeme{xNewLine, "NL"}
	case unicode.IsDigit(ch) || ch == '-' || ch == '+':
		look = lexeme{xNumber, string(ch)}
		for ch = read(); unicode.IsDigit(ch); ch = read() {
			look.value += string(ch)
		}
		source.UnreadRune()
	case unicode.IsLetter(ch):
		look = lexeme{xIdent, ""}
		for unicode.IsLetter(ch) || unicode.IsDigit(ch) {
			look.value += string(ch)
			ch = read()
		}
		source.UnreadRune()
		if isKeyword(look.value) {
			look.token = xKeyword
		}
	}
}
````


## Բայթ-կոդի ստեղծման միջոցները

Բայթ-կոդի ստեղծումն ավելի հեշտացնելու համար իրականացրել եմ `bytecode` փաթեթը։ Սրա `Builder` օբյեկտը մեթոդներ է տրամադրում մեքենայի յուրաքանչյուր հրամանի գեներացիայի համար։ Բացի ամեն մի հրամանի սիմվոլիկ անունին և այդ հրամանի արգումենտներին բայթերի հաջորդականություն համապատասխանացնելը, `Builder` օբյեկ


Բոլոր հրամանների սիմվոլիկ անունները սահմանել եմ որպես `machine` (մեքենա) փաթեթի հաստատուններ.

````Go
package machine

// Մեքենայի հրամանների անուները (կոդերը)
const (
	None byte = iota
	Add
	And
	Alloc
	Call
	Div
	Dup
	Enter
	Eq
	Geq
	Gr
	Halt
	Jump
	JumpI
	JumpZ
	Leq
	Le
	Load
	LoadA
	LoadC
	LoadR
	LoadRC
	Malloc
	Mark
	Mod
	Mul
	Neg
	Neq
	New
	Not
	Or
	Pop
	Return
	Slide
	Store
	StoreA
	StoreR
	Sub
)
````

